许多异步操作需要分配一个对象来存储与该操作相关的状态。例如，Win32实现需要 OVERLAPPED派生对象传递给Win32 API函数。

此外，程序通常包含易于识别的异步操作链。半双工协议实现（例如HTTP服务器）将为每个客户端提供单个操作链（接收后跟发送）。全双工协议实现将有两个并行执行的链。程序应该能够利用这些知识为链中的所有异步操作重用内存。

给定一个用户定义Handler 对象的副本h，如果实现需要分配与该处理程序关联的内存，它将执行代码：

void *  pointer  =  asio_handler_allocate （size ， &h ）;
同样，要释放它将执行的内存：

asio_handler_deallocate （指针， 大小， & ）;
使用与参数相关的查找来定位这些函数。该实现提供了asio命名空间中上述函数的默认实现：

void *  asio_handler_allocate （size_t ， ...）; 
void  asio_handler_deallocate （void *， size_t ， ...）;
分别 按照和分别实施。 ::operator new()::operator delete()

该实现保证在调用关联的处理程序之前将发生解除分配，这意味着内存已准备好重用于处理程序启动的任何新的异步操作。

可以从调用库函数的任何用户创建的线程调用自定义内存分配函数。该实现保证，对于包含库的异步操作，实现不会对该处理程序的内存分配函数进行并发调用。如果需要从不同的线程调用分配函数，实现将插入适当的内存屏障以确保正确的内存可见性。