#vector底层机制
增加因子 是多少
#list自带排序函数的排序原理
list是双向链表


#vector list deque
下几条：
如果需要随机访问一个容器，vector比list要好
如果需要经常插入和删除操作的话，list比vector要好
如果既要随机存取，又要关心两端数据的插入和删除，则选择deque

#vector 和 deque 
deque和vector的区别 ，
1前者可以以常数的时间，在头部插入元素
2 deque 没有所谓的 容量概念，随时可以新增一段空间，拼接上来
 

#deque stack queue
deque 双端队列
stack 堆栈
queue 队列

    stack是一种先进后出（FILO）的数据结构，它只有一个出口。deque是双向开口的数据结构，所以SGI STL便以deque作为缺省情况下的stack底部结构，封闭其头端开口。stack没有迭代器，所以除了顶部元素，无法存取其它元素，即不能遍历stack。
      stack的成员函数都是针对其顶部元素进行操作：push()，pop()，top()。
      queue是一种先进先出（FIFO）的数据结构，它有两个出口。queue也是以deque作为底部结构，封闭其底端的出口和前端的入口。queue，只有顶端（两端）的元素能被外部使用，所以queue也没有迭代器，不提供遍历功能。
      queue的成员函数有：front()，back()，push()，pop()。
      可以看到stack和queue的成员函数以及特性都是针对其数据结构来的，所以深入理解其内部结构，不易与deque众多的成员函数混淆。当然stack和queue也可以list为底层结构实现。

#deque的内部实现
https://www.cnblogs.com/Rosanna/p/3512635.html

#vector 与deque的区别
开口单向和双向
内存增加方式


# 没有迭代器，不允许遍历的容器有哪些
queue stack heap 都不能


#queue和stack的内部实现


#hashmap和 map的区别

http://blog.163.com/liuruigong_lrg/blog/static/27370306200711334341781/

map,而且效率很高，
  
    具有对数平均时间的 效率；

100万条记录，最多也只要20次的的比较，就能找到你要找的记录;200万条记录事，也只要用21次的比较。
速度永远都满足不了现实的需求。如果有100万条记录，我需要频繁进行搜索时，20次比较也会成为瓶颈，要是能降到一次或者两次比较是否有可能？而且当记录数到200万的时候也是一次或者两次的比较，是否有可能？而且还需要和map一样的方便使用。
答案是肯定的。这时你需要has_map. 虽然hash_map目前并没有纳入C++ 标准模板库中，但几乎每个版本的STL都提供了相应的实现。而且应用十分广泛。在正式使用hash_map之前，先看看hash_map的原理

    hashmap 空间换取时间的思想

hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的 情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。

其基本原理是：使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下 标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对 应的地方，称为桶。

但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。

    总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。

hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：

1得到key  
2通过hash函数得到hash值  
3得到桶号(一般都为hash值对桶数求模)  
4存放key和value在桶内。  

其取值过程是:
1得到key  
2通过hash函数得到hash值  
3 得到桶号(一般都为hash值对桶数求模)  
4 比较桶的内部元素是否与key相等，若都不相等，则没有找到。  
5 取出相等的记录的value。

    hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。
这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).
由此可见，要实现哈希表, 和用户相关的是：
  
     hash函数和比较函数。
  
  这两个参数刚好是我们在使用hash_map时需要指定的参数。


#map 自动排序 而hashmap没有
map默认按照key的 less函数 比较函数，自动排序，
比较函数可以指定

map有自动排序功能，而hashmap没有



#set与序列式容器的区别
set 键值唯一，并且不能通过迭代器修改其值 ，
set 还可以做交集，并集，补集等操作 。序列式容器不能




#对map insert 和操作符 []访问的问题

map的键值，也是不可以修改的，但其value可以被修改


pair<iterator ,bool > insert (const value_type & x):
如果 key，已经存在，则返回的bool 为false，iterator指向已经存在的元素
如果key，不存在， 则返回bool 为true，iterator 指向插入的元素的位置；
map[] 可以作为左值，也可以作为右值 。


T & operator [](const key_type & k)
{
	insert ( *(insert(value_type( k, T())).first) ).second;
}
map的 [ ]  先插入空元素，然后  再获取值，
如果已经存在key,则回去原值，
如果key不存在，则获取插入的空值。
 这样，操作的后果，如果 原来没有改key，则操作后，会给改key,插入一个空值




# map和mutilmap的区别

# list vector map 等 erease it后，迭代器的变化
map set和list有相同的性质，如果对其进行元素的新增inset和delete ，操作之前的迭代器，在操作之后，依然可用。
list的插入和接合操作（splice） 对原来的迭代器，没有影响


#stl的面试题


https://www.cnblogs.com/wulala1119/p/4758345.html
https://blog.csdn.net/tianya_team/article/details/50753759
https://blog.csdn.net/weiyuefei/article/details/52089146
https://blog.csdn.net/tianya_team/article/details/50753759
