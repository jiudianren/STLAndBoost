#序列式容器和关联式容器的基本概念

数据在容器中的排列的特性  划分为 序列式和关联式

序列式容器中的元素都是可排的，但未必是有序的。
关联式容器，容器内的每个元素都有一个键值，和一个实值 。当元素被插入的时候，容器内部便依赖其键值，以某种规则将其放在适当的位置。（对set来说，其键值就是实值。）



#vector底层机制
增加因子 是多少
#list自带排序函数的排序原理
list是双向链表


#vector list deque
下几条：
如果需要随机访问一个容器，vector比list要好
如果需要经常插入和删除操作的话，list比vector要好
如果既要随机存取，又要关心两端数据的插入和删除，则选择deque

#vector 和 deque 
deque和vector的区别 ，
1前者可以以常数的时间，在头部插入元素
2 deque 没有所谓的 容量概念，随时可以新增一段空间，拼接上来
 

#deque stack queue
deque 双端队列
stack 堆栈
queue 队列

    stack是一种先进后出（FILO）的数据结构，它只有一个出口。deque是双向开口的数据结构，所以SGI STL便以deque作为缺省情况下的stack底部结构，封闭其头端开口。stack没有迭代器，所以除了顶部元素，无法存取其它元素，即不能遍历stack。
      stack的成员函数都是针对其顶部元素进行操作：push()，pop()，top()。
      queue是一种先进先出（FIFO）的数据结构，它有两个出口。queue也是以deque作为底部结构，封闭其底端的出口和前端的入口。queue，只有顶端（两端）的元素能被外部使用，所以queue也没有迭代器，不提供遍历功能。
      queue的成员函数有：front()，back()，push()，pop()。
      可以看到stack和queue的成员函数以及特性都是针对其数据结构来的，所以深入理解其内部结构，不易与deque众多的成员函数混淆。当然stack和queue也可以list为底层结构实现。

#deque的内部实现
https://www.cnblogs.com/Rosanna/p/3512635.html

#vector 与deque的区别
开口单向和双向
内存增加方式


# 没有迭代器，不允许遍历的容器有哪些
queue stack heap 都不能


#queue和stack的内部实现

#map和multimap的底层实现的差异



#为何map和set的插入删除效率比用其他序列容器高


	或许有得人能回答出来大概原因，但要彻底明白，还需要了解STL的底层数据结构。
	C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：
	红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般的平衡二叉树(有些书籍根据作者姓名，Adelson-Velskii和Landis，将其称为AVL树)，所以被STL选择作
	为了关联容器的内部结构。本文并不会介绍详细AVL树和RB树的实现以及他们的优劣，关于RB树的详细实现参看红黑树: 理论与实现(理论篇)。本文针对开始提出的几个问题的回答
	来向大家简单介绍map和set的底层数据结构。为何map和set的插入删除效率比用其他序列容器高？
	大部分人说，很简单，
	
	因为对于关联容器来说，不需要做内存拷贝和内存移动。
	
	
	说对了，确实如此。map和set容器内所有元素都是以红黑树节点（如下）的方式来存储，其节点
	结构和链表差不多，指向父节点和子节点。结构图可能如下：
	   A
	  /  \
	 B    C
	/ \  /  \
	D E  F  G
	
	因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换
	去，和内存移动没有关系。


# 为何map和set不能像vector一样有个reserve函数来预分配数据？

	内部结构是tree，起元素的排列与元素的大小有关。
	

#为何每次insert之后，以前保存的iterator不会失效？


	看见了上面答案的解释，你应该已经可以很容易解释这个问题。iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已
	经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在
	删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。


#当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？

	如果你知道log2的关系你应该就彻底了解这个答案。在map和set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次
	。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/1
	4的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了

#hashmap和 map的区别

http://blog.163.com/liuruigong_lrg/blog/static/27370306200711334341781/



####hash_map和map的区别在哪里?
构造函数。hash_map需要hash函数，等于函数;map只需要比较函数(小于函数).
存储结构。hash_map采用hash表存储，map一般采用 红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。

#### 什么时候需要用hash_map，什么时候需要用map?

总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的构造速度较慢。

现在知道如何选择了吗?权衡三个因素: 查找速度, 数据量, 内存使用。


map,而且效率很高，
  
    具有对数平均时间的 效率；

100万条记录，最多也只要20次的的比较，就能找到你要找的记录;200万条记录事，也只要用21次的比较。
速度永远都满足不了现实的需求。如果有100万条记录，我需要频繁进行搜索时，20次比较也会成为瓶颈，要是能降到一次或者两次比较是否有可能？而且当记录数到200万的时候也是一次或者两次的比较，是否有可能？而且还需要和map一样的方便使用。
答案是肯定的。这时你需要has_map. 虽然hash_map目前并没有纳入C++ 标准模板库中，但几乎每个版本的STL都提供了相应的实现。而且应用十分广泛。在正式使用hash_map之前，先看看hash_map的原理

    hashmap 空间换取时间的思想

hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的 情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。

其基本原理是：使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下 标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对 应的地方，称为桶。

但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。

    总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。

hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：

1得到key  
2通过hash函数得到hash值  
3得到桶号(一般都为hash值对桶数求模)  
4存放key和value在桶内。  

其取值过程是:
1得到key  
2通过hash函数得到hash值  
3 得到桶号(一般都为hash值对桶数求模)  
4 比较桶的内部元素是否与key相等，若都不相等，则没有找到。  
5 取出相等的记录的value。

    hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。
这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).
由此可见，要实现哈希表, 和用户相关的是：
  
     hash函数和比较函数。
  
  这两个参数刚好是我们在使用hash_map时需要指定的参数。


#map 自动排序 而hashmap没有
map默认按照key的 less函数 比较函数，自动排序，
比较函数可以指定

map有自动排序功能，而hashmap没有



#set与序列式容器的区别
set 键值唯一，并且不能通过迭代器修改其值 ，
set 还可以做交集，并集，补集等操作 。序列式容器不能




#对map insert 和操作符 []访问的问题

map的键值，也是不可以修改的，但其value可以被修改


pair<iterator ,bool > insert (const value_type & x):
如果 key，已经存在，则返回的bool 为false，iterator指向已经存在的元素
如果key，不存在， 则返回bool 为true，iterator 指向插入的元素的位置；
map[] 可以作为左值，也可以作为右值 。


T & operator [](const key_type & k)
{
	insert ( *(insert(value_type( k, T())).first) ).second;
}
map的 [ ]  先插入空元素，然后  再获取值，
如果已经存在key,则回去原值，
如果key不存在，则获取插入的空值。
 这样，操作的后果，如果 原来没有改key，则操作后，会给改key,插入一个空值




# map和mutilmap的区别

# list vector map 等 erease it后，迭代器的变化
map set和list有相同的性质，如果对其进行元素的新增inset和delete ，操作之前的迭代器，在操作之后，依然可用。
list的插入和接合操作（splice） 对原来的迭代器，没有影响


#stl的面试题


https://www.cnblogs.com/wulala1119/p/4758345.html
https://blog.csdn.net/tianya_team/article/details/50753759
https://blog.csdn.net/weiyuefei/article/details/52089146
https://blog.csdn.net/tianya_team/article/details/50753759
