
# shared_ptr 

std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向
一个对象，从而消除显示的调用 delete ，当引用计数变为零的时候就会将对象
自动删除。
但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代
码出现了某种程度上的不对称，std::make_shared 就能够用来消除显示的使用 new ，所
以 std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型
的 std::shared_ptr 指针


#std::unique_ptr 
std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个
对象，从而保证代码的安全

既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转
移给其他的 unique_ptr 

std::make_unique<int>

#weak_ptr

解决shared_ptr相互引用是，共享指针无法释放的问题。


	struct A;
	struct B;
	struct A {
	std::shared_ptr<B> pointer;
	~A() {
	std::cout << "A 被销毁" << std::end;
	}
	};
	struct B {
	std::shared_ptr<A> pointer;
	~B() {
	std::cout << "B 被销毁" << std::end;
	}
	};
	int main() {
	auto a = std::make_shared<A>();
	auto b = std::make_shared<B>();
	a.pointer = b;
	b.pointer = a;
	}
	
运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了
a,b ，这使得 a,b 的引用计数均变为了 2，而离开作用域时， a,b 智能指针
被析构，却智能造成这块区域的引用计数减一，这样就导致了 a,b 对象指向的内
存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄
露，